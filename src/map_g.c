#include "globals_structs_const.h"int random_walls = 0;void save_mp(const char *maze, int width, int height) {    int x, y, i, rx, ry;    for (y = 0; y < height; y++)        for (x = 0; x < width; x++) {            if (x % 2 == 0 && y % 2 == 1 && maze[y * width + x] == 1) {                wal_v[(y - 1) / 2][x / 2] = 1;            }            if (x % 2 == 1 && y % 2 == 0 && maze[y * width + x] == 1) {                wal_h[y / 2][(x - 1) / 2] = 1;            }        }    random_walls = (S_x+S_y)/10;//    random_walls = 0;    for (i = 0; i < random_walls;) {        rx = rand() % S_x / 2;        ry = rand() % S_y / 2 + 1;        if (wal_v[ry][rx + 1]) {            wal_v[ry][rx + 1] = 0;            i++;        }    }    for (i = 0; i < random_walls;) {        rx = rand() % S_x / 2 + 1;        ry = rand() % S_y / 2;        if (wal_h[ry + 1][rx]) {            wal_h[ry + 1][rx] = 0;            i++;        }    }    for (i = 0; i < random_walls;) {        rx = rand() % S_x / 2;        ry = rand() % S_y / 2;        if (wal_v[ry + S_y / 2][rx + 1]) {            wal_v[ry + S_y / 2][rx + 1] = 0;            i++;        }    }    for (i = 0; i < random_walls;) {        rx = rand() % S_x / 2;        ry = rand() % S_y / 2;        if (wal_h[ry + 1][rx + S_x / 2]) {            wal_h[ry + 1][rx + S_x / 2] = 0;            i++;        }    }    for (i = 0; i < random_walls;) {        rx = rand() % S_x / 2;        ry = rand() % S_y / 2;        if (wal_h[ry + S_y / 2][rx]) {            wal_h[ry + S_y / 2][rx] = 0;            i++;        }    }    for (i = 0; i < random_walls;) {        rx = rand() % S_x / 2;        ry = rand() % S_y / 2;        if (wal_v[ry][rx + S_x / 2]) {            wal_v[ry][rx + S_x / 2] = 0;            i++;        }    }    for (i = 0; i < random_walls;) {        rx = rand() % S_x / 2;        ry = rand() % S_y / 2;        if (wal_h[ry + S_y / 2][rx + S_x / 2]) {            wal_h[ry + S_y / 2][rx + S_x / 2] = 0;            i++;        }    }    for (i = 0; i < random_walls;) {        rx = rand() % S_x / 2;        ry = rand() % S_y / 2;        if (wal_v[ry + S_y / 2][rx + S_x / 2]) {            wal_v[ry + S_y / 2][rx + S_x / 2] = 0;            i++;        }    }}void ShowMaze(const char *maze, int width, int height) {    int x, y;    for (y = 0; y < height; y++) {        for (x = 0; x < width; x++) {            switch (maze[y * width + x]) {                case 1:                    printf("[]");                    break;                case 2:                    printf("<>");                    break;                default:                    printf("  ");                    break;            }        }        printf("\n");    }}void backtrack(char *maze, int width, int height, int x, int y) {    int x1, y1;    int x2, y2;    int dx, dy;    int dir, count;    dir = rand() % 4;    count = 0;    while (count < 4) {        dx = 0;        dy = 0;        switch (dir) {            case 0:                dx = 1;                break;            case 1:                dy = 1;                break;            case 2:                dx = -1;                break;            default:                dy = -1;                break;        }        x1 = x + dx;        y1 = y + dy;        x2 = x1 + dx;        y2 = y1 + dy;        if (x2 > 0 && x2 < width && y2 > 0 && y2 < height && maze[y1 * width + x1] == 1 && maze[y2 * width + x2] == 1) {            maze[y1 * width + x1] = 0;            maze[y2 * width + x2] = 0;            x = x2;            y = y2;            dir = rand() % 4;            count = 0;        } else {            dir = (dir + 1) % 4;            count += 1;        }    }}int mp_gen() {    for (int i = 0; i < 11; ++i) {        for (int j = 0; j < 11; ++j) {            wal_v[i][j] = 0;            wal_h[i][j] = 0;        }    }    srand(time(NULL));    S_x = rand() % 2 + 7;    S_y = rand() % 2 + 7;    int width = 2 * S_x + 1, height = 2 * S_y + 1;    char *maze;    maze = (char *) malloc(width * height * sizeof(char));    int x, y;    for (x = 0; x < width * height; x++) {        maze[x] = 1;    }    maze[1 * width + 1] = 0;    int i;    for (y = 1; y < height; y += 2) {        for (x = 1; x < width; x += 2) {            backtrack(maze, width, height, x, y);        }    }    save_mp(maze, width, height);//    ShowMaze(maze, width, height);    free(maze);}void readmap() {    FILE *fp;    fp = fopen("/home/hadi/project/97101156/base/src/map.txt", "r");    char get_line[20];    int n, i, j, k, y, x2, y2, x1, y1;    srand(time(NULL));    k = (rand() % 3) + 1;    for (i = 0; i < k;) {        fgets(get_line, 255, fp);        if (get_line[0] == 10)            i++;    }    fscanf(fp, "%d", &n);    for (i = 0; i < n; i++) {        fscanf(fp, "%d %d %d %d", &x1, &y1, &x2, &y2);        if (S_y < y2)S_y = y2;        if (S_x < x2)S_x = x2;        if (x1 == x2)            for (j = y1; j < y2; j++) {                wal_v[j][x2] = 1;            }        if (y2 == y1)            for (j = x1; j < x2; j++)                wal_h[y1][j] = 1;    }}